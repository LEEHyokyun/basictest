#n*m 크기의 금광이 있고, 각 1*1크기의 칸으로 나뉘어져 있다.
#각 칸 별로 특정 개수의 금광이 들어있다.
#채굴자는 첫번째 열부터 금을 캐되 시작 행은 정할 수 있다.
#특정 행에서 출발하여 m-1번에 거쳐 오른쪽위, 오른쪽, 오른쪽 아래 중 하나로 이동이 가능하다.
#채굴자가 얻을 수 있는 금의 최대 크기는 구하는 알고리즘은?

#이는 모든 노드에 대한 경우의 수를 고려하는 것도 아니고
#최단경로를 구하는 것도 아니다.
#일전 인접하지 않은 식량창고 유형과 상당히 비슷한데
#일전 최적의 해에 무엇인가 누적할 수 있을 방안으로 구하면 될 것 같다.

#첫째줄에 테스트 케이스 T가 입력된다.
#매 테스트 케이스 첫째 줄에 n m이 공백으로 구분되어 입력된다.
#둘쨰 줄에 n*m의 위치에 매장된 금의 개수가 공백으로 구분되어 입력된다.

#테스트 케이스마다 금의 최대 크기를 출력하도록 구성한다.

##모든 위치에 대하여 이동할 수 있는 경우의 수는 3가지이다.
##이때 bfs인가 생각할 수도 있겠지만, 결국 금의 최대 개수를 갱신하는 것이 관건.
##각 케이스 별 가능한 경우의 수마다 금의 최대 개수를 바꾼다 -> 점화식 이용.

#점화식 구성, 지금까지 구한 최대의 해 교체, 최적의 해
#d[i][j] = array[i][j] + max(dp[i-1][j-1], dp[i+1][j-1], dp[i][j-1])
#단 각 경우의 수마다 인덱스가 범위 내인지 체크
#다만 마찬가지로 이동 가능한 경우 모두 고려(이 관점에 한해서만 bfs)
import sys

for tc in range(int(input())):
    n, m = map(int, sys.stdin.readline().split())
    array = list(map(int, sys.stdin.readline().split()))

    dp = []
    index = 0

    #입력받은 후 2차원 dp table 초기화
    for i in range(n):
        dp.append(array[index:index+m])
        # 0부터 m까지 단위로 열이 분할됨
        # 열이 분할되는 순간 행이 바뀌는 반복문을 구현한 것
        index = index + m

    #DP진행, 열을 하나씩 이동하면서 최대값 도출
    for j in range(1, m):
        for i in range(n):
            #왼쪽 위에서 오는 경우(범위도 확인) 이전 경로의 값
            if i == 0: left_up = 0 #0번째 행
            else: left_up = dp[i-1][j-1]
            #왼쪽 아래에서 오는 경우(범위도 확인) 이전 경로의 값
            if i == n-1: left_down = 0
            else: left_down = dp[i+1][j-1]
            #왼쪽에서 오는 경우 이전 경로의 값
            left = dp[i][j-1]

            #이전 경로의 값은 이미 최대값이 반영된 상태
            #그 중에서 최대값을 선택해서 반영하면 됨
            dp[i][j] = dp[i][j] + max(left_up, left_down, left)

    result = 0
    #결과는 가장 오른쪽 "열"에 모두 적혀져 있다.
    for i in range(n):
        result = max(result, dp[i][m-1])
    print(result)



